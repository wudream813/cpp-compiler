{
	"C++ Code": {
		"prefix": [
			"code",
			"#include"
		],
		"body": [
			"#include<bits/stdc++.h>",
			"",
			"using namespace std;",
			"using ll = long long;",
			"",
			"int main(){",
			"    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
			"    ${0}",
			"    return 0;",
			"}"
		],
		"description": "常用代码片段"
	},
	"segtree": {
		"prefix": "segtree",
		"body": [
			"struct Node{",
			"    ${1:/*something...*/}",
			"};",
			"",
			"struct segtree{",
			"    #define getmid int mid = (l + r >> 1)",
			"    Node tr[MAXN << 2];",
			"    const Node E = {${2:/*something...*/}};",
			"    Node comb(const Node &a, const Node &b) {",
			"        return {${3:/*something...*/}};",
			"    }",
			"    void build(int id, int l, int r) {",
			"        if(l == r) {",
			"            ${4:/*something...*/}",
			"            return;",
			"        }",
			"        getmid;",
			"        build(id << 1, l, mid), build(id << 1 | 1, mid + 1, r);",
			"        tr[id] = comb(tr[id << 1], tr[id << 1 | 1]);",
			"    }",
			"    void change(int id, int l, int r, int cx, int cs) {",
			"        if(l == r) {",
			"            ${5:/*something...*/}",
			"            return;",
			"        }",
			"        getmid;",
			"        if(cx <= mid)change(id << 1, l, mid, cx, cs);",
			"        else change(id << 1 | 1, mid + 1, r, cx, cs);",
			"        tr[id] = comb(tr[id << 1], tr[id << 1 | 1]);",
			"    }",
			"    Node ask(int id, int l, int r, int al, int ar) {",
			"        if(al <= l && ar >= r) {",
			"            return tr[id];",
			"        }",
			"        if(ar < l || al > r || ar < al) {",
			"            return E;",
			"        }",
			"        getmid;",
			"        return comb(ask(id << 1, l, mid, al, ar), ask(id << 1 | 1, mid + 1, r, al, ar));",
			"    }",
			"};",
			"",
			"#define All 1, 1, size"
		],
		"description": "普通的单修区查线段树"
	},
	"lazy_segtree": {
		"prefix": "lazy_segtree",
		"body": [
			"struct Node{",
			"    ${1:/*something...*/}",
			"};",
			"",
			"struct Tag{",
			"    ${2:/*something...*/}",
			"",
			"    bool operator == (const Tag &oth) {",
			"        return ${3:/*something...*/};",
			"    }",
			"};",
			"",
			"struct Segtree{",
			"    #define getmid int mid = (l + r) >> 1",
			"    Node tr[MAXN << 2];",
			"    Tag tag[MAXN << 2];",
			"    const Node E = {${4:/*something...*/}};",
			"    const Tag I = {${5:/*something...*/}};",
			"    ",
			"    Node comb(const Node &a, const Node &b) {",
			"        return {${6:/*something...*/}};",
			"    }",
			"    ",
			"    Tag F(const Tag &n, const Tag &y) {",
			"        return {${7:/*something...*/}};",
			"    }",
			"    ",
			"    Node f(const Node &x, const Tag &t) {",
			"        return {${8:/*something...*/}};",
			"    }",
			"    ",
			"    void down(int id) {",
			"        if(tag[id] == I)return;",
			"        tr[id << 1] = f(tr[id << 1], tag[id]);",
			"        tag[id << 1] = F(tag[id << 1], tag[id]);",
			"        tr[id << 1 | 1] = f(tr[id << 1 | 1], tag[id]);",
			"        tag[id << 1 | 1] = F(tag[id << 1 | 1], tag[id]);",
			"        tag[id] = I;",
			"    }",
			"    ",
			"    void build(int id, int l, int r) {",
			"        tag[id] = I;",
			"        if(l == r){",
			"            ${9:/*something...*/}",
			"            return;",
			"        }",
			"        getmid;",
			"        build(id << 1, l, mid), build(id << 1 | 1, mid + 1, r);",
			"        tr[id] = comb(tr[id << 1], tr[id << 1 | 1]);",
			"    }",
			"    ",
			"    void change(int id, int l, int r, int cl, int cr, Tag tg) {",
			"        if(cl <= l && cr >= r) {",
			"            tr[id] = f(tr[id], tg);",
			"            tag[id] = F(tag[id], tg);",
			"            return;",
			"        }",
			"        down(id);",
			"        getmid;",
			"        if(cl <= mid)change(id << 1, l, mid, cl, cr, tg);",
			"        if(cr > mid)change(id << 1 | 1, mid + 1, r, cl, cr, tg);",
			"        tr[id] = comb(tr[id << 1], tr[id << 1 | 1]);",
			"    }",
			"    ",
			"    Node ask(int id, int l, int r, int al, int ar) {",
			"        if(al <= l && ar >= r){",
			"            return tr[id];",
			"        }",
			"        if(ar < l || al > r || ar < al){",
			"            return E;",
			"        }",
			"        down(id);",
			"        getmid;",
			"        return comb(ask(id << 1, l, mid, al, ar), ask(id << 1 | 1, mid + 1, r, al, ar));",
			"    }",
			"}T;",
			"",
			"#define All 1, 1, size"
		],
		"description": "区修区查的懒标记线段树"
	},
	"Fenwick": {
		"prefix": "Fenwick",
		"body": [
			"struct Fenwick {",
			"    int c[MAXN];",
			"    int n;",
			"",
			"    int lowbit(int x) {",
			"        return x & -x;",
			"    }",
			"",
			"    void add(int x, int ad) {",
			"        for (; x <= n; x += lowbit(x))c[x] += ad;",
			"    }",
			"",
			"    int ask(int q) {",
			"        int ans = 0;",
			"        for (; q; q -= lowbit(q))ans += c[q];",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "普通树状数组"
	},
	"qpow": {
		"prefix": "qpow",
		"body": [
			"ll qpow(ll a, int b) {",
			"  ll ans = 1;",
			"  for(; b; b >>= 1) {",
			"    if(b & 1)ans = ans * a;",
			"    a = a * a;",
			"  }",
			"  return ans;",
			"}"
		],
		"description": "普通快速幂"
	},
	"mqpow": {
		"prefix": "mqpow",
		"body": [
			"ll qpow(ll a, int b, const int &MOD) {",
			"  ll ans = 1;",
			"  for(; b; b >>= 1) {",
			"    if(b & 1)ans = ans * a % MOD;",
			"    a = a * a % MOD;",
			"  }",
			"  return ans;",
			"}"
		],
		"description": "带取模快速幂"
	},
	"dsu": {
		"prefix": "dsu",
		"body": [
			"struct dsu{",
			"    int n;",
			"    int Fa[MAXN];",
			"    int sz[MAXN];",
			"",
			"    void Init(int l){",
			"        n = l;",
			"        for(int i = 1; i <= n; i++) {",
			"            Fa[i] = i;",
			"            sz[i] = 1;",
			"        }",
			"    }",
			"",
			"    int Find(int x){",
			"        return (Fa[x] == x) ? x : Fa[x] = Find(Fa[x]);",
			"    }",
			"",
			"    bool Merge(int a, int b){",
			"        int fa = Find(a), fb = Find(b);",
			"        if(fa == fb)return 0;",
			"        if(sz[fa] > sz[fb])swap(fa, fb);",
			"        Fa[fa] = fb, sz[fb] += sz[fa];",
			"        return 1;",
			"    };",
			"}"
		],
		"description": "并查集"
	},
	"Trie": {
		"prefix": "Trie",
		"body": [
			"struct Trie{",
			"    int cnt[MAXL];",
			"    int nxt[MAXL][MAXZ];",
			"    int tot;",
			"    void init() {",
			"        tot = 0;",
			"    }",
			"    void insert(string s) {",
			"        int rt = 0;",
			"        for(char ch : s) {",
			"            if(!nxt[rt][ch])nxt[rt][ch] = ++tot;",
			"            rt = nxt[rt][ch];",
			"            cnt[rt]++;",
			"        }",
			"    }",
			"    int ask(string s) {",
			"        int rt = 0;",
			"        for(char ch : s) {",
			"            ch -= '0';",
			"            if(!nxt[rt][ch])return 0;",
			"            rt = nxt[rt][ch];",
			"        }",
			"        return cnt[rt];",
			"    }",
			"    void del(string s) {",
			"        int rt = 0;",
			"        for(char ch : s) {",
			"            ch -= '0';",
			"            if(!nxt[rt][ch])return;",
			"            rt = nxt[rt][ch];",
			"            cnt[rt]--;",
			"        }",
			"    }",
			"};"
		],
		"description": "字典树"
	},
	"ST": {
		"prefix": "ST",
		"body": [
			"struct ST{",
			"    int st[LOGN + 2][MAXN];",
			"    int Log2[MAXN];",
			"    void init(int n) {",
			"        Log2[0] = -1;",
			"        for(int i = 1; i <= n; i++){",
			"            st[i][0] = ${1:/*something*/};",
			"            Log2[i] = Log2[i >> 1] + 1;",
			"        }",
			"        for(int i = 1; i <= LOGN; i++) {",
			"            for(int j = 1; j <= n + 1 - (1 << i); j++) {",
			"                st[j][i] = ${2|max, min|}(st[i - 1][j], st[i - 1][j + (1 << i - 1)][i - 1]);",
			"            }",
			"        }",
			"    }",
			"    int ask(int l, int r) {",
			"        int lg = Log2[r - l + 1];",
			"        return max(st[lg][l], st[lg][r - (1 << lg) + 1]);",
			"    }",
			"};"
		],
		"description": "普通 ST 表"
	},
	"Random": {
		"prefix": "Rand",
		"body": [
			"$CURRENT_SECOND$RANDOM"
		],
		"description": "产生随机值"
	},
	"Info": {
		"description": "插入代码信息",
		"body": [
			"/*",
			"------- INFO -------",
			"> Date:$CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE",
			"> Time:$CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
			"> Filename:$TM_FILENAME",
			"> Path:$TM_FILEPATH",
			"--------------------",
			"*/"
		],
		"prefix": "Info"
	},
	"Pb_ds": {
		"prefix": "Pb_ds",
		"body": [
			"#include<bits/extc++.h>",
			"",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"using ll = long long;",
			"",
			"int main(){",
			"    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
			"    return 0;",
			"}"
		],
		"description": "使用 Pb_ds 库"
	},
	"freopen": {
		"prefix": [
			"Freopen",
			"contest"
		],
		"body": [
			"freopen(\"$TM_FILENAME_BASE.in\", \"r\", stdin);",
			"freopen(\"$TM_FILENAME_BASE.out\", \"w\", stdout);"
		],
		"description": "freopen 文件读写"
	},
	"Lca": {
		"prefix": "Lca",
		"body": [
			"struct LCA{",
			"    static const int LOGN = ${1:20};",
			"    int D[MAXN];",
			"    int Fa[LOGN + 2][MAXN];",
			"    ",
			"    void dfs(int u, int fa) {",
			"        D[u] = D[fa] + 1;",
			"        for (int v : e[u]) {",
			"            if (v == fa)continue;",
			"            Fa[0][v] = u;",
			"            dfs(v, u);",
			"        }",
			"    }",
			"",
			"    void init(int root) {",
			"        dfs(root, 0);",
			"        for (int lg = 1; lg <= LOGN; lg++) {",
			"            for (int i = 1; i <= n; i++) {",
			"                Fa[lg][i] = Fa[lg - 1][Fa[lg - 1][i]];",
			"            }",
			"        }",
			"    }",
			"",
			"    int query(int a, int b) {",
			"        if (D[a] < D[b])swap(a, b);",
			"        for (int i = LOGN; ~i; i--) {",
			"            if (D[Fa[i][a]] >= D[b]) {",
			"                a = Fa[i][a];",
			"            }",
			"        }",
			"        if (a == b)return a;",
			"        for (int i = LOGN; ~i; i--) {",
			"            if (Fa[i][a] != Fa[i][b]) {",
			"                a = Fa[i][a], b = Fa[i][b];",
			"            }",
			"        }",
			"        return Fa[0][a];",
			"    }",
			"}T;"
		],
		"description": "Lca"
	},
	"MAXN": {
		"prefix": "MAXN",
		"body": [
			"const int MAXN = ${1:1}e${2:5} + ${1:1}${2:5};${0}"
		],
		"description": "const int MAXN = "
	},
	"Testcase": {
		"prefix": "Testcase",
		"body": [
			"#include<bits/stdc++.h>",
			"",
			"using namespace std;",
			"using ll = long long;",
			"",
			"void solve(){",
			"    ${0}",
			"}",
			"",
			"int main(){",
			"    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
			"    int T;",
			"    for(cin >> T; T--; solve());",
			"    return 0;",
			"}"
		],
		"description": "解决多组数据"
	},
	"List": {
		"prefix": "list",
		"body": [
			"struct Node{",
			"    int pre, nxt;",
			"};",
			"",
			"struct List{",
			"    Node a[MAXN];",
			"    int st, ed;",
			"    ",
			"    void init(int n) {",
			"        st = 0, ed = n + 1;",
			"        a[st].nxt = ed;",
			"        a[ed].pre = st;",
			"        ${1}",
			"    }",
			"    ",
			"    void insert_left(int x, int y) {",
			"        a[a[x].pre].nxt = y;",
			"        a[y].pre = a[x].pre;",
			"        a[x].pre = y;",
			"        a[y].nxt = x;",
			"    }",
			"    ",
			"    void insert_right(int x, int y) {",
			"        a[a[x].nxt].pre = y;",
			"        a[y].nxt = a[x].nxt;",
			"        a[x].nxt = y;",
			"        a[y].pre = x;",
			"    }",
			"    ",
			"    void del(int x) {",
			"        a[a[x].pre].nxt = a[x].nxt;",
			"        a[a[x].nxt].pre = a[x].pre;",
			"    }",
			"    ",
			"    bool empty() {",
			"        return a[st].nxt == ed;",
			"    }",
			"    ",
			"    void print() {",
			"        for(int i = a[st].nxt; i != ed; i = a[i].nxt) {",
			"            cout << i << ' ';",
			"        }",
			"    }",
			"};"
		],
		"description": "双向链表"
	},
	"FastIO": {
		"prefix": "FastIO",
		"body": [
			"namespace FastIO {",
			"    #define FastIO_RepStd ${1:1}",
			"    #define FastIO_Sign ${2:1}",
			"    #define FastIO_UseFread ${3:1}",
			"    #define BUF_SIZE (1 << 15)",
			"    struct IO {",
			"        char buf[BUF_SIZE], * p1, * p2;char pbuf[BUF_SIZE], * pp;IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }",
			"        inline char gc() {",
			"            #if FastIO_UseFread",
			"                if (__builtin_expect(p1 == p2, 0)) {p2 = (p1 = buf) + fread(buf, 1, BUF_SIZE, stdin);if(__builtin_expect(p1 == p2, 0))return 0;}return *p1++;",
			"            #else",
			"                #ifdef __linux__",
			"                int ch = getchar_unlocked();",
			"                #else ",
			"                int ch = _getchar_nolock();",
			"                #endif",
			"                return (__builtin_expect(~ch, 1) ? ch : 0);",
			"            #endif",
			"        }",
			"        template<typename T>inline void read(T& x) {",
			"            #if FastIO_Sign",
			"                bool sign = 0;",
			"            #endif",
			"            x = 0;",
			"            char ch = gc();",
			"            for (; !isdigit(ch) && ch; ch = gc()) {",
			"                #if FastIO_Sign ",
			"                    sign |= ch == '-';",
			"                #endif",
			"            }",
			"            for (; isdigit(ch); ch = gc()) {",
			"                #if FastIO_Sign",
			"                    x = x * 10 + (sign ? '0' - ch : ch - '0');",
			"                #else",
			"                    x = x * 10 + ch - '0';",
			"                #endif",
			"            }",
			"        }",
			"        template<typename T>inline void write(T x){",
			"            static int sta[40];int top = 0;",
			"            #if FastIO_Sign",
			"                if (x < 0){push('-'), x = ~x;int tmp = x % 10;x /= 10;sta[top++] = (__builtin_expect(tmp == 9, 0) ? (x++, 0) : tmp + 1);}",
			"            #endif",
			"            do {sta[top++] = x % 10;x /= 10;}while (x);while (top) push('0' + sta[--top]);",
			"        }",
			"        inline void read(char& c) { for (c = gc(); isspace(c) && c; c = gc()); }inline void read_line(char *str) { int i = 0; for (char c = gc(); (c ^ 10) && c; c = gc(), i++)str[i] = c; }inline void read_line(string &str) { str.clear(); int i = 0; for (char c = gc(); (c ^ 10) && c; c = gc(), i++)str.push_back(c); }inline void read(bool& x) {int tmp;read(tmp);x = tmp;}template<typename T, typename ...Tp> inline void read(T& x, Tp &...y) { read(x), read(y...); }inline void push(const char& c) {if (pp - pbuf == BUF_SIZE) fwrite(pbuf, 1, BUF_SIZE, stdout), pp = pbuf;*pp++ = c;}inline void write(const char& ch) { push(ch); }inline void write(const char* s) { for (size_t i = 0; i < strlen(s); i++)push(s[i]); }inline void write(const string &str) { for (const char &ch : str)push(ch); }inline void write(bool x) {push(x ? 49 : 48);}template<typename T, typename ...Tp> inline void write(const T x, const Tp ...y) { write(x), write(y...); }",
			"    }io;",
			"    struct Reader {template<typename T>inline const Reader& operator >> (T& x) const {io.read(x);return *this;}inline void getline(char *str) {io.read_line(str);}inline void getline(string &str) {io.read_line(str);}inline char get() {return io.gc();}}cin;struct Writer {template<typename T>inline const Writer& operator << (const T& x) const {io.write(x);return *this;}}cout;",
			"    #if FastIO_RepStd",
			"    #define cin FastIO::cin",
			"    #define cout FastIO::cout",
			"    #define read FastIO::io.read",
			"    #define write FastIO::io.write",
			"    #define getchar FastIO::io.gc",
			"    #endif",
			"    #undef FastIO_RepStd ",
			"    #undef FastIO_Sign",
			"    #undef FastIO_UseFread",
			"}"
		],
		"description": "快速读入模板"
	}
}